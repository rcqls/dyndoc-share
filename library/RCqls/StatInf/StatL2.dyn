[#require]RCqls/StatInf/HypoTest
[#package]\usepackage{framed}
[#main][#R<]require(CqlsEAP)[#<]
{#def]qcmSrv[#,]srv[][#,]what[][#>]
[{#case]#{what}
[#when]H0[#>][{#H0]srv.test[#}][#when]h0[#>][{#H0Theta]srv.test[#}]
[#when]H0|<[#>][{#qcmBadH0]srv.test[#,]<[#}][#when]h0|<[#>][{#qcmBadH0Theta]srv.test[#,]<[#}]
[#when]H0|>[#>][{#qcmBadH0]srv.test[#,]>[#}][#when]h0|>[#>][{#qcmBadH0Theta]srv.test[#,]>[#}]
[#when]H0|!=[#>][{#qcmBadH0]srv.test[#,]\neq[#}][#when]h0|!=[#>][{#qcmBadH0Theta]srv.test[#,]\neq[#}]
[#when]H0|Y[#>][{#qcmBadH0Y]srv.test[#}]
[#%]H0,H0|<,H0|>,H0|!=,H0|Y

[#%]H1,H1|<=,H1|>=,H1|=
[#when]H1[#>][{#H1]srv.test[#}][#when]h1[#>][{#H1Theta]srv.test[#}]
[#when]H1|<=[#>][{#qcmBadH1]srv.test[#,]\leq[#}][#when]h1|<=[#>][{#qcmBadH1Theta]srv.test[#,]\leq[#}]
[#when]H1|>=[#>][{#qcmBadH1]srv.test[#,]\geq[#}][#when]h1|>=[#>][{#qcmBadH1Theta]srv.test[#,]\geq[#}]
[#when]H1|=[#>][{#qcmBadH1]srv.test[#,]=[#}][#when]h1|=[#>][{#qcmBadH1Theta]srv.test[#,]=[#}]

[#%]stH0,lstH0,lstH0|y
[#when]stH0,StatTestH0[#>][{#deltaEstH0ExprTex]srv.test[#,]va[true][#}]
[#when]lstH0,loiStatTestH0[#>][{#StatTestH0]srv.test[#}]
[#when]lstH0|y,loiStatTestH0|y[#>][{#StatTestH0]srv.test[#,]va[false][#}]

[#%]rdq,rdp|alpha,rdp|Y,rdp,rdp|>,rdp|qlim
[#when]rdq,RDQ[#>][{#RD]srv.test[#,]q[#}]
[#when]rdp|alpha[#>][{#qcmBadRD]srv.test[#,]q|alpha[#}]
[#when]rdq|Y[#>][{#qcmBadRD]srv.test[#,]q|Y[#}]
[#when]rdp,RDP[#>][{#RD]srv.test[#,]p[#}]
[#when]rdp|>[#>][{#qcmBadRD]srv.test[#,]p|>[#}]
[#when]rdp|qlim[#>][{#qcmBadRD]srv.test[#,]p|qlim[#}]

[#%]pvalR,pvalNum
[#when]pvalR[#>][p-valeur\NotR\texttt{{#pvalR]srv.test[#}}]
[#when]pvalNum[#>][p-valeur={#pvalNum]srv.test[#}]

[#%]deltaH0R,deltaH0Num,deltaLimLeftR,deltaLimRightR,deltaLimLeftNum,deltaLimRightNum
[#when]deltaH0R[#>][${#deltaEstH0Tex]srv.test[#,]false[#}$\NotR\texttt{{#deltaH0R]srv.test[#}}]
[#when]deltaH0Num[#>][${#deltaEstH0Tex]srv.test[#,]false[#}$={#deltaH0Num]srv.test[#}]
[#when]deltaLimLeftR[#>][${#deltaLimTex]srv.test[#,]<[#}$\NotR {#deltaLimR]srv.test[#}]
[#when]deltaLimRightR[#>][${#deltaLimTex]srv.test[#,]>[#}$\NotR {#deltaLimR]srv.test[#}]
[#when]deltaLimLeftNum[#>][${#deltaLimTex]srv.test[#,]<[#}$={#deltaLimNum]srv.test[#}]
[#when]deltaLimRightNum[#>][${#deltaLimTex]srv.test[#,]>[#}$={#deltaLimNum]srv.test[#}]

[#%]ppsn,ppsp,ppp
[#when]ppsn,PreSignNum[#>][{#PP]srv.test[#,]sign-num[#}]
[#when]ppsp,PreSignPValG[#>][{#PP]srv.test[#,]sign-pvalg[#}]
[#when]ppp,PreParam[#>][{#PP]srv.test[#,]param[#}]

[#%]AsIs
[#when]AsIs[#>][:{h1}]
[#case}]
[#def}


What I want: {#qcmSrvH1]p(A) > 0.15[#,]H0[#} H0 could be H1, stH0 (stat de test H0), rdq (quantile),rdp (p-valeur), ccl... and pp (partie prelim)
When <what> contains "|" this means that there is a modifier for bad answer:
Example: H0|< or H0:> or HO|!= mean that this is a false answer for H0
Rmk: method starting by qcmBad is generally only used for qcm goal!
%%% Facility Class
{#def]qcmSrvH1[#,]h1[][#,]what[][#,]cadre[a][#,]data[][#,]initR[][#,]envR[envHypoTestExo]
[#rb<]h1=#{=h1}
#p :h1;p h1
if h1 =~ /^(p|m|v|md|dm|dv|rm|rv)\(([^\(\)]*)\)(<|>|\!\=)([^<>]*)$/
  par,pb,side,refR= [$1,$2,$3,$4]
  #p [par,pb,side,refR]
  pbs=pb.split(",")
  if par.length == pbs.length
  else
    Dyndoc.warn "burk"
  end
else
  par=[] # as is
end
#p [#{=type},par,pb,pbs,refR]
[#?]par.length==1
[#<]{#new]qcmSrv[#of]HypoTestExo[#in]#{envR}
[#,]:{par}[#,]#{cadre}[#,]nomPb[:{pb}]
[#,]side[:{side}][#,]theta0R[:{refR}]
[#R<]
if(#{=data} != "") load(path.data("#{data}.RData"))
#{initR}
[#new}
[#?]par.length==2
[#<]{#new]qcmSrv[#of]HypoTestExo[#in]#{envR}
[#,]:{par}[#,]#{cadre}[#,]nom1Pb[:{pbs[0]}][#,]nom2Pb[:{pbs[1]}]
[#,]side[:{side}][#,]theta0R[:{refR}]
[#R<]
if(#{=data} != "") load(path.data("#{data}.RData"))
#{initR}
[#new}
[#?]end
[#rb<]#p [#{=what},par,pb,pbs,refR]
[#>][{#qcmSrv]:qcmSrv[#what]#{what}[#}]
[#def}

{#def]qcmFramed[#,]content[][#>]
\begin{framed}
\noindent \textbf{Réponses aux choix (pour remplir le Formulaire de REPONSES)}~:\\
#{content}
\end{framed}
[#def}


{#def]qcmChoices[#,]title[][#,]choices[][#,]space[\quad][#,]size[]
[#rb<]choices=#{=choices}.strip
#p [:choices,choices]
res_table=[]
lignes=choices.split("\n").map{|e| e.strip}
#p [:lignes,lignes]
lignes.each do |ligne| #
  #p [:ligne,ligne]
  unless ["%","#"].include? ligne[0,1]
    res_ligne=[]
    if ligne[0,2]=='<<'
      lab,*rest=ligne[2..-1].split(">>")
      ligne=rest.join(">>").strip
      res_ligne << lab #not a Hash
    end
    unless ligne.empty?
      elts=ligne.split(" | ").map{|e| e.strip}
      elts.each do |elt| #
        res_elt={}
        res_elt[:txt],opt=elt.split(":").map{|e| e.strip}
        opts=opt.split("&").each{|e| res_elt[$1.to_sym] = $2 if e.strip =~ /^(space|size)\=(.*)$/} if opt
        res_ligne << res_elt
      end
    end
    res_table << res_ligne
  end
end
#
p [:res_table,res_table]
[#rb>]
cpt=-1
quest=[]
#Dyndoc.warn :res_table,[res_table,res_table.length]
res_table.each_with_index do |res_ligne,li| #
  {#>]\noindent [#>}
  #Dyndoc.warn :res_ligne,[li,res_ligne]
  res_ligne.each do |res_elt| #
    if res_elt.is_a? String
      {#>]:{res_elt}[#>}
    else
      cpt+=1
      label=(("A".ord)+cpt).chr
      txt,answer=(res_elt[:txt][-1,1]=="*" ? [res_elt[:txt][0...-1],:good] : [res_elt[:txt],:bad] )
      size=res_elt[:size] || ""
      size=#{=size} if size.empty? and #{+?size}
      quest << {label: label, answer: answer}
      {#>]\fbox{:{label}}~ {#if]size[#>]{:{size} [#} :{txt} {#if]size[#>]}[#} :{res_elt[:space] || '#{space}'}[#>}
    end
  end
  {#>]\\[#>} if li != res_table.length-1 and !(res_ligne.length==1 and res_ligne[0].is_a? String)
end
# format of title is: <family title>::<key>
prj,title,k=#{=title}.split("/")
# ensure that $qcm and $qcm[title] exists
$qcm={} unless $qcm
$qcm[prj]={} unless $qcm[prj]
$qcm[prj][title]={} unless $qcm[prj][title]
$qcm[prj][title][k] = quest
## QUESTION: can be also saved as a whole object in ~/dyndoc/???
dir=File.expand_path File.join("~",".qcmAMC")
unless File.directory? dir
  require 'fileutils'
  FileUtils.mkdir_p dir
end
File.open(File.join(dir,prj+".qcm"),"w") {|f| f << $qcm[prj].inspect}
[#def}

### NOT FINISHED!!!
{#def]qcmChoicesList[#,]title[][#,]content[]
[#=]title[:{#{=title}.strip}]
[#rb<]content=#{=content}.split("\\n")
content.keys.each do |k| #
  txt=content[k]
#p :txt,[k,txt]
  opts={}
  first=txt[0].strip
  if first[0,1]=='(' and first[-1,1]==')'
    ## read the options
    first[1...-1].split('),(').each{|e| opts[$1.to_sym] = $2 if e.strip =~ /^(space|size)\=(.*)$/}
    ## update txt
    txt=txt[1..-1]
  end
  txt=txt.join("\n")
#p :txt,txt.inspect
  {#>][#=]test.:{k.to_s}[{#qcmTest]#{title}/:{k.to_s}[#,]space[:{opts[:space] || '\quad'}][#,]size[:{opts[:size] || ''}][#choices]:{txt}[#qcmTest}][#>}
end
[#>]
{#qcmFramed]
[\noindent \underline{Hypothèses de test}~:\\
\noindent $\mathbf{H_0}$:\quad
#{test.h0}

\noindent $\mathbf{H_1}$:\quad
#{test.h1}

\noindent\underline{Statistique de test sous $\mathbf{H_0}$}~:\\
#{test.st}

\noindent\underline{Règle de Décision}~: Accepter $\mathbf{H_1}$ si~:
#{test.rd}

\noindent\underline{Conclusion}~: Au vu des données, \\
#{test.an}]
[#qcmFramed}
[#def}

The numbers of elements of every lines may differ!
* at the end of <h1> means good answer

<h1-11>* @ what : data=<data-11> & env=<env-11> & init=<init-11> & space=<size-11> | <h1-12> : data=<data-12> & env=<env-12> & init=<init-12> & size=<size-12> | ...
<h1-21> : data=<data-21> & env=<env-21> & init=<init-21> & space=<size-21> | <h1-22> : data=<data-22> & env=<env-22> & init=<init-22> & size=<size-22> | ...
...
<h1-p1> : data=<data-p1> & env=<env-p1> & init=<init-p1> & size=<size-p1> | <h1-p2> : data=<data-p2> & env=<env-p2> & init=<init-p2> & size=<size-p2> | ...

{#def]qcmTest[#,]title[][#,]choices[][#,]space[\quad][#,]size[]
[#rb<]choices=#{=choices}.strip
#p [:choices,choices]
res_table=[]
lignes=choices.split("\n").map{|e| e.strip}
#p [:lignes,lignes]
lignes.each do |ligne| #
  #p [:ligne,ligne]
  unless ["%","#"].include? ligne[0,1]
    res_ligne=[]
    elts=ligne.split(" | ").map{|e| e.strip}
    elts.each do |elt| #
      res_elt={}
      h1,opt=elt.split(":").map{|e| e.strip}
      res_elt[:h1],res_elt[:what]=h1.split("@").map{|e| e.strip}
      opts=opt.split("&").each{|e| res_elt[$1.to_sym] = $2 if e.strip =~ /^(cadre|data|env|init|space|size)\=(.*)$/} if opt
      res_ligne << res_elt
    end
    res_table << res_ligne
  end
end
#p [:res_table,res_table]
[#rb>]
cpt=-1
quest=[]
#Dyndoc.warn :res_table,[res_table,res_table.length]
res_table.each_with_index do |res_ligne,li| #
  {#>]\noindent [#>}
  #Dyndoc.warn :res_ligne,[li,res_ligne]
  res_ligne.each do |res_elt| #
    cpt+=1
    label=(("A".ord)+cpt).chr
    h1,answer=(res_elt[:h1][-1,1]=="*" ? [res_elt[:h1][0...-1],:good] : [res_elt[:h1],:bad] )
    size=res_elt[:size] || ""
    size=#{=size} if size.empty? and #{+?size}
    quest << {label: label, answer: answer}
    {#>]\fbox{:{label}}~ {#if]size[#>]{:{size} [#}{#qcmSrvH1]:{h1}[#,]:{res_elt[:what] || "AsIs"}[#cadre]:{res_elt[:cadre] || "a"}[#data]:{res_elt[:data] || "#{data}"}[#initR]:{res_elt[:init] || ""}[#envR]:{res_elt[:env] ||"envHypoTestExo"}[#}{#if]size[#>]}[#} :{res_elt[:space] || '#{space}'}[#>}
  end
  {#>]\\[#>} if li != res_table.length-1
end
# format of title is: <family title>::<key>
prj,title,k=#{=title}.split("/")
# ensure that $qcm and $qcm[title] exists
$qcm={} unless $qcm
$qcm[prj]={} unless $qcm[prj]
$qcm[prj][title]={} unless $qcm[prj][title]
$qcm[prj][title][k] = quest
## QUESTION: can be also saved as a whole object in ~/dyndoc/???
dir=File.expand_path File.join("~",".qcmAMC")
unless File.directory? dir
  require 'fileutils'
  FileUtils.mkdir_p dir
end
File.open(File.join(dir,prj+".qcm"),"w") {|f| f << $qcm[prj].inspect}
[#def}

{#def]qcmRedStd[#,]title[][#,]H0[][#,]H1[][#,]StatTest[][#,]RD[][#,]Conclusion[]
[#=]title[:{#{=title}.strip}]
[#rb<]content={h0: '#{H0}'.strip.split("\n"), h1: '#{H1}'.strip.split("\n"), st: '#{StatTest}'.strip.split("\n"), rd: '#{RD}'.strip.split("\n"), an: '#{Conclusion}'.strip.split("\n")}
content.keys.each do |k| #
  txt=content[k]
#p :txt,[k,txt]
  opts={}
  first=txt[0].strip
  if first[0,1]=='(' and first[-1,1]==')'
    ## read the options
    first[1...-1].split('),(').each{|e| opts[$1.to_sym] = $2 if e.strip =~ /^(space|size)\=(.*)$/}
    ## update txt
    txt=txt[1..-1]
  end
  txt=txt.join("\n")
#p :txt,txt.inspect
  {#>][#=]test.:{k.to_s}[{#qcmTest]#{title}/:{k.to_s}[#,]space[:{opts[:space] || '\quad'}][#,]size[:{opts[:size] || ''}][#choices]:{txt}[#qcmTest}][#>}
end
[#>]
{#qcmFramed]
[\noindent \underline{Hypothèses de test}~:\\
\noindent $\mathbf{H_0}$:\quad
#{test.h0}

\noindent $\mathbf{H_1}$:\quad
#{test.h1}

\noindent\underline{Statistique de test sous $\mathbf{H_0}$}~:\\
#{test.st}

\noindent\underline{Règle de Décision}~: Accepter $\mathbf{H_1}$ si~:
#{test.rd}

\noindent\underline{Conclusion}~: Au vu des données, \\
#{test.an}]
[#qcmFramed}
[#def}

#####################################
#### QCM File: new, free, save load
#####################################
{#def]qcmInit[#,]prj[]
[#rb<]
$qcm={} unless $qcm
prj=#{=prj}
##p [:prj,prj]
unless $qcm[prj]
  qcmAMC=File.expand_path File.join("~",".qcmAMC",prj+".qcm")
  #p [qcmAMC,(File.exists? qcmAMC)]
  if File.exist? qcmAMC
    $qcm[prj]=eval(File.read(qcmAMC))
    ##p [:qcm,$qcm[prj]]
  end
end
[#def}

{#def]qcmLoad[#,]title[]
[#rb<]prj,title,key=#{=title}.split("/")
p [:qcmLoad,prj,title,key]
[#<]{#qcmInit]:{prj}[#}
[#rb<]p [:qcm,$qcm[prj]]
[#rb>]
if $qcm[prj] and $qcm[prj][title]
  {#>][\begin{questionmult}{q:{title}-:{key}}\bareme{mz=1}\begin{reponsesperso}[o]][#>}
  $qcm[prj][title][key].each do |a| #
    choix="\\" + (a[:answer] == :good ? "bonne" : "mauvaise")
    {#>]:{choix}{:{a[:label]}\quad}[#>}
  end
  {#>][\end{reponsesperso}\end{questionmult}][#>}
end
[#def}

{#def]qcmLoadHypoTest[#,]title[]
[#rb<]prj,title=#{=title}.split("/")
p #{=title}
[#<]{#qcmInit]:{prj}[#}
[#rb<]p [:q,prj,title,$qcm[prj][title]]
[#rb>]
if $qcm[prj] and qcm=$qcm[prj][title]
Dyndoc.warn :q,[:q,qcm]
    {#>]\noindent\underline{Hypothèses de Test}~:[#nl][#nl][#>}
    qcm.keys.each do |key| #
      txt = case key
      when "h0","h1"
        "$\\mathbf{"+key[0,1].upcase+"_"+key[1,1]+"}$~:"
      when "st"
        "\\noindent \\underline{Statistique de Test sous $\\mathbf{H_0}$}~:"
      when "rd"
        "\\noindent \\underline{Règle de Décision}~:"
      when "an"
        "\\noindent \\underline{Conclusion}~:"
      end
      {#>]:{txt} {#qcmLoad]:{prj}/:{title}/:{key}[#}[#nl][#nl][#>}
    end
end
[#def}

##########################################
#        QCM Server Stuff
##########################################
####  Partie Préliminaire en 3 parties
##########################################
{#meth]PP.TestParam[#,] type[sign-num]
[#=]theta0Rtmp[{#if]:r{#{.theta0R}>=0}[#>]#{.theta0R}[#else](#{.theta0R})[#if}]
[#>]
  [{#if]#{=.frame.paramType}=="md"
  [#>]{#case]#{type}
  [#when]sign-num[#>] [$\mathtt{(mean(#{.frame.yR})-#{theta0Rtmp})}\simeq#r{round((mean(#{.frame.yR})-#{.theta0R}),2)}$]
  [#when]sign-pvalg[#>][p-valeur gauche {#if]:r{leftpval<=.5}[#>]inférieure[#else]supérieure[#if} à $50\%$]
  [#when]param[#>][$#{.frame.thetaTex}=\mbox{``moyenne de $#{.frame.YTex}$"}=\mu^{#{.frame.nom1Pb}}-\mu^{#{.frame.nom2Pb}}$ avec $#{.frame.YTex}=Y^{#{.frame.nom1Pb}}-Y^{#{.frame.nom2Pb}}$]
  [#case}[#if}]
[#>]
  [{#if]#{.frame.nbEch}==2 and #{=.frame.paramType}+#{=.frame.sampleType}!="rvg"
  [#>]{#case]#{type}
  [#when]sign-num[#>] [$\mathtt{(#{.frame.thetaEstFctR}(#{.frame.y1R})#{.frame.operation}#{.frame.thetaEstFctR}(#{.frame.y2R})-#{theta0Rtmp})}\simeq#r{#{.frame.thetaEstFctR}(#{.frame.y1R})#{.frame.operation}#{.frame.thetaEstFctR}(#{.frame.y2R})-#{.theta0R}}$]
  [#when]sign-pvalg[#>][p-valeur gauche est {#if]:r{leftpval<=.5}[#>]inférieure[#else]supérieure[#if} à $50\%$]
  [#when]param[#>][$#{.frame.thetaTex}=#{.frame.thetaExprTex}$]
  [#case}[#if}]
[#}
##########################################
#### QCM BAD Answers
##########################################
## Bad answer for H0 et H1
{#meth]qcmBadH0.TestParam [#,]side[<][#>] [$\mathbf{H}_0:$ $#{.frame.thetaTex}#{side}#{.theta0Tex}$] [#}
{#meth]qcmBadH1.TestParam [#,]side[=][#>] [$\mathbf{H}_1:$ $#{.frame.thetaTex}#{side}#{.theta0Tex}$] [#}
{#meth]qcmBadH0Theta.TestParam[#,]side[<][#>][$#{.frame.thetaTex}#{side}#{.theta0Tex}$] [#}
{#meth]qcmBadH1Theta.TestParam[#,]side[=][#,] expr[false]
[#>] [$#{.frame.thetaTex}{#if]#{expr} and #{.frame.nbEch}==2[#>] [:=#{.frame.thetaExprTex}] [#}#{side}#{.theta0Tex}$]
[#}
{#meth]qcmBadH0Y.TestParam[#>][$\mathbf{H}_0:$ ${#thetaTex]self[#}#{side}#{.theta0Tex}$][#}
## Bad RD
{#meth]qcmBadRD.TestParam[#,]indic[][#>]
[{#case]#{indic}
  [#when]p|>[#>][p-valeur > #{.alphaTex}]
  [#when]p|qlim[#>]
    [p-valeur {#case]#{.side} [#when]<[#>] [ < {#deltaLimTex]self[#,]<[#}] [#when]>[#>] [ > <  {#deltaLimTex]self[#,]>[#}] [#when]!=,\neq[#>] [ < {#deltaLimTex]self[#,]>[#}] [#case}]
  [#when]q|alpha[#>]
    [{#case]#{.side}
    [#when]<[#>] [${#deltaEstH0Tex]self[#,]false[#} < #{.alphaTex}$]
    [#when]>[#>] [${#deltaEstH0Tex]self[#,]false[#} > #{.alphaTex} {#deltaLimTex]self[#,]>[#}$]
    [#when]!=,\neq[#>][${#deltaEstH0Tex]self[#,]false[#} < \frac{#{.alphaTex}}2$ ou ${#deltaEstH0Tex]self[#,]false[#} > \frac{#{.alphaTex}}2$]
    [#}]
  [#when]q|Y[#>]
    [{#case]#{.side}
    [#when]<[#>] [${#deltaEstH0Tex]self[#,]true[#} < {#deltaLimTex]self[#,]<[#}$]
    [#when]>[#>] [${#deltaEstH0Tex]self[#,]true[#} > {#deltaLimTex]self[#,]>[#}$]
    [#when]!=,\neq[#>][${#deltaEstH0Tex]self[#,]true[#} < {#deltaLimTex]self[#,]<[#}$ ou ${#deltaEstH0Tex]self[#,]true[#} > {#deltaLimTex]self[#,]>[#}$]
    [#}]
  [#}]
[#}
## Bad Conclusion
